function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var EventEmitter = require('eventemitter3');

var modification = require('modification');

var Tick = require('tick-tock');

var ms = require('millisecond');

var one = require('one-time');

var emits = require('emits');
/**
 * Generate a somewhat unique UUID.
 *
 * @see stackoverflow.com/q/105034
 * @returns {String} UUID.
 * @private
 */


function UUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function gen(c) {
    var random = Math.random() * 16 | 0,
        value = c !== 'x' ? random & 0x3 | 0x8 : random;
    return value.toString(16);
  });
}
/**
 * Emit when modifications are made.
 *
 * @type {Fucntion}
 * @private
 */


var change = require('modification')(' change');
/**
 * A nope function for when people don't want message acknowledgements. Because
 * they don't care about CAP.
 *
 * @private
 */


function nope() {}
/**
 * Representation of a single raft node in the cluster.
 *
 * Options:
 *
 * - `address`: An unique id of this given node.
 * - `heartbeat`: Heartbeat timeout.
 * - `election min`: Minimum election timeout.
 * - `election max`: Maximum election timeout.
 * - `threshold`: Threshold when the heartbeat RTT is close to the election
 *   timeout.
 * - `Log`: A Log constructor that should be used to store commit logs.
 * - `state`: Our initial state. This is a private property and should not be
 *   set you unless you know what your are doing but as you want to use this
 *   property I highly doubt that that..
 *
 * Please note, when adding new options make sure that you also update the
 * `Raft#join` method so it will correctly copy the new option to the clone as
 * well.
 *
 * @constructor
 * @param {Mixed} address Unique address, id or name of this given raft node.
 * @param {Object} options Raft configuration.
 * @public
 */


var Raft =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(Raft, _EventEmitter);

  function Raft(address) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Raft);

    _this = _possibleConstructorReturn(this, (Raft.__proto__ || Object.getPrototypeOf(Raft)).call(this));

    var raft = _assertThisInitialized(_this);

    if ('object' === _typeof(address)) options = address;else if (!options.address) options.address = address;
    raft.election = {
      min: ms(options['election min'] || '150 ms'),
      max: ms(options['election max'] || '300 ms')
    };
    raft.beat = ms(options.heartbeat || '50 ms');
    raft.votes = {
      for: null,
      // Who did we vote for in this current term.
      granted: 0 // How many votes we're granted to us.

    };
    raft.write = raft.write || options.write || null;
    raft.threshold = options.threshold || 0.8;
    raft.address = options.address || UUID();
    raft.timers = new Tick(raft);
    raft.Log = options.Log;
    raft.change = change;
    raft.emits = emits;
    raft.latency = 0;
    raft.log = null;
    raft.nodes = []; //
    // Raft ยง5.2:
    //
    // When a server starts, it's always started as Follower and it will remain in
    // this state until receive a message from a Leader or Candidate.
    //

    raft.state = options.state || Raft.FOLLOWER; // Our current state.

    raft.leader = ''; // Leader in our cluster.

    raft.term = 0; // Our current term.

    raft._initialize(options);

    return _this;
  }
  /**
   * Initialize Raft and start listening to the various of events we're
   * emitting as we're quite chatty to provide the maximum amount of flexibility
   * and reconfigurability.
   *
   * @param {Object} options The configuration you passed in the constructor.
   * @private
   */


  _createClass(Raft, [{
    key: "_initialize",
    value: function _initialize(options) {
      var raft = this; //
      // Reset our vote as we're starting a new term. Votes only last one term.
      //

      raft.on('term change', function change() {
        raft.votes.for = null;
        raft.votes.granted = 0;
      }); //
      // Reset our times and start the heartbeat again. If we're promoted to leader
      // the heartbeat will automatically be broadcasted to users as well.
      //

      raft.on('state change', function change(state) {
        raft.timers.clear('heartbeat, election');
        raft.heartbeat(Raft.LEADER === raft.state ? raft.beat : raft.timeout());
        raft.emit(Raft.states[state].toLowerCase());
      }); //
      // Receive incoming messages and process them.
      //

      raft.on('data',
      /*#__PURE__*/
      function () {
        var _ref = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(packet, write) {
          var reason, _ref2, _index, _term, _ref3, term, index, hasIndex, _entry, entries, entry, _entries, previousEntry, append;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  write = write || nope;

                  if (!('object' !== raft.type(packet))) {
                    _context.next = 9;
                    break;
                  }

                  reason = 'Invalid packet received';
                  raft.emit('error', new Error(reason));
                  _context.t0 = write;
                  _context.next = 7;
                  return raft.packet('error', reason);

                case 7:
                  _context.t1 = _context.sent;
                  return _context.abrupt("return", (0, _context.t0)(_context.t1));

                case 9:
                  if (!(packet.term > raft.term)) {
                    _context.next = 13;
                    break;
                  }

                  raft.change({
                    leader: Raft.LEADER === packet.state ? packet.address : packet.leader || raft.leader,
                    state: Raft.FOLLOWER,
                    term: packet.term
                  });
                  _context.next = 17;
                  break;

                case 13:
                  if (!(packet.term < raft.term)) {
                    _context.next = 17;
                    break;
                  }

                  reason = 'Stale term detected, received `' + packet.term + '` we are at ' + raft.term;
                  raft.emit('error', new Error(reason));
                  return _context.abrupt("return", write(raft.packet('error', reason)));

                case 17:
                  //
                  // Raft ยง5.2:
                  //
                  // If we receive a message from someone who claims to be leader and shares
                  // our same term while we're in candidate mode we will recognize their
                  // leadership and return as follower.
                  //
                  // If we got this far we already know that our terms are the same as it
                  // would be changed or prevented above..
                  //
                  if (Raft.LEADER === packet.state) {
                    if (Raft.FOLLOWER !== raft.state) raft.change({
                      state: Raft.FOLLOWER
                    });
                    if (packet.address !== raft.leader) raft.change({
                      leader: packet.address
                    }); //
                    // Always when we receive an message from the Leader we need to reset our
                    // heartbeat.
                    //

                    raft.heartbeat(raft.timeout());
                  }

                  _context.t2 = packet.type;
                  _context.next = _context.t2 === 'vote' ? 21 : _context.t2 === 'voted' ? 51 : _context.t2 === 'error' ? 68 : _context.t2 === 'append' ? 70 : _context.t2 === 'append ack' ? 105 : _context.t2 === 'append fail' ? 114 : _context.t2 === 'exec' ? 122 : 123;
                  break;

                case 21:
                  if (!(raft.votes.for && raft.votes.for !== packet.address)) {
                    _context.next = 28;
                    break;
                  }

                  raft.emit('vote', packet, false);
                  _context.t3 = write;
                  _context.next = 26;
                  return raft.packet('voted', {
                    granted: false
                  });

                case 26:
                  _context.t4 = _context.sent;
                  return _context.abrupt("return", (0, _context.t3)(_context.t4));

                case 28:
                  if (!raft.log) {
                    _context.next = 41;
                    break;
                  }

                  _context.next = 31;
                  return raft.log.getLastInfo();

                case 31:
                  _ref2 = _context.sent;
                  _index = _ref2.index;
                  _term = _ref2.term;

                  if (!(_index > packet.last.index && _term > packet.last.term)) {
                    _context.next = 41;
                    break;
                  }

                  raft.emit('vote', packet, false);
                  _context.t5 = write;
                  _context.next = 39;
                  return raft.packet('voted', {
                    granted: false
                  });

                case 39:
                  _context.t6 = _context.sent;
                  return _context.abrupt("return", (0, _context.t5)(_context.t6));

                case 41:
                  //
                  // We've made our decision, we haven't voted for this term yet and this
                  // candidate came in first so it gets our vote as all requirements are
                  // met.
                  //
                  raft.votes.for = packet.address;
                  raft.emit('vote', packet, true);
                  raft.change({
                    leader: packet.address,
                    term: packet.term
                  });
                  _context.t7 = write;
                  _context.next = 47;
                  return raft.packet('voted', {
                    granted: true
                  });

                case 47:
                  _context.t8 = _context.sent;
                  (0, _context.t7)(_context.t8);
                  //
                  // We've accepted someone as potential new leader, so we should reset
                  // our heartbeat to prevent this raft from timing out after voting.
                  // Which would again increment the term causing us to be next CANDIDATE
                  // and invalidates the request we just got, so that's silly willy.
                  //
                  raft.heartbeat(raft.timeout());
                  return _context.abrupt("break", 132);

                case 51:
                  if (!(Raft.CANDIDATE !== raft.state)) {
                    _context.next = 57;
                    break;
                  }

                  _context.t9 = write;
                  _context.next = 55;
                  return raft.packet('error', 'No longer a candidate, ignoring vote');

                case 55:
                  _context.t10 = _context.sent;
                  return _context.abrupt("return", (0, _context.t9)(_context.t10));

                case 57:
                  //
                  // Increment our received votes when our voting request has been
                  // granted by the raft that received the data.
                  //
                  if (packet.data.granted) {
                    raft.votes.granted++;
                  } //
                  // Check if we've received the minimal amount of votes required for this
                  // current voting round to be considered valid.
                  //


                  if (!raft.quorum(raft.votes.granted)) {
                    _context.next = 66;
                    break;
                  }

                  raft.change({
                    leader: raft.address,
                    state: Raft.LEADER
                  }); //
                  // Send a heartbeat message to all connected clients.
                  //

                  _context.t11 = raft;
                  _context.t12 = Raft.FOLLOWER;
                  _context.next = 64;
                  return raft.packet('append');

                case 64:
                  _context.t13 = _context.sent;

                  _context.t11.message.call(_context.t11, _context.t12, _context.t13);

                case 66:
                  //
                  // Empty write, nothing to do.
                  //
                  write();
                  return _context.abrupt("break", 132);

                case 68:
                  raft.emit('error', new Error(packet.data));
                  return _context.abrupt("break", 132);

                case 70:
                  _context.next = 72;
                  return raft.log.getLastInfo();

                case 72:
                  _ref3 = _context.sent;
                  term = _ref3.term;
                  index = _ref3.index;

                  if (!(packet.last.index !== index && packet.last.index !== 0)) {
                    _context.next = 89;
                    break;
                  }

                  _context.next = 78;
                  return raft.log.has(packet.last.index);

                case 78:
                  hasIndex = _context.sent;

                  if (!hasIndex) {
                    _context.next = 83;
                    break;
                  }

                  raft.log.removeEntriesAfter(packet.last.index);
                  _context.next = 89;
                  break;

                case 83:
                  _context.t14 = raft;
                  _context.t15 = Raft.LEADER;
                  _context.next = 87;
                  return raft.packet('append fail', {
                    term: packet.last.term,
                    index: packet.last.index
                  });

                case 87:
                  _context.t16 = _context.sent;
                  return _context.abrupt("return", _context.t14.message.call(_context.t14, _context.t15, _context.t16));

                case 89:
                  if (!packet.data) {
                    _context.next = 99;
                    break;
                  }

                  _entry = packet.data[0];
                  _context.next = 93;
                  return raft.log.saveCommand(_entry.command, _entry.term, _entry.index);

                case 93:
                  _context.t17 = raft;
                  _context.t18 = Raft.LEADER;
                  _context.next = 97;
                  return raft.packet('append ack', {
                    term: _entry.term,
                    index: _entry.index
                  });

                case 97:
                  _context.t19 = _context.sent;

                  _context.t17.message.call(_context.t17, _context.t18, _context.t19);

                case 99:
                  if (!(raft.log.committedIndex < packet.last.committedIndex)) {
                    _context.next = 104;
                    break;
                  }

                  _context.next = 102;
                  return raft.log.getUncommittedEntriesUpToIndex(packet.last.committedIndex, packet.last.term);

                case 102:
                  entries = _context.sent;
                  raft.commitEntries(entries);

                case 104:
                  return _context.abrupt("break", 132);

                case 105:
                  _context.next = 107;
                  return raft.log.commandAck(packet.data.index, packet.address);

                case 107:
                  entry = _context.sent;

                  if (!(raft.quorum(entry.responses.length) && !entry.committed)) {
                    _context.next = 113;
                    break;
                  }

                  _context.next = 111;
                  return raft.log.getUncommittedEntriesUpToIndex(entry.index, entry.term);

                case 111:
                  _entries = _context.sent;
                  raft.commitEntries(_entries);

                case 113:
                  return _context.abrupt("break", 132);

                case 114:
                  _context.next = 116;
                  return raft.log.get(packet.data.index);

                case 116:
                  previousEntry = _context.sent;
                  _context.next = 119;
                  return raft.appendPacket(previousEntry);

                case 119:
                  append = _context.sent;
                  write(append);
                  return _context.abrupt("break", 132);

                case 122:
                  return _context.abrupt("break", 132);

                case 123:
                  if (!raft.listeners('rpc').length) {
                    _context.next = 127;
                    break;
                  }

                  raft.emit('rpc', packet, write);
                  _context.next = 132;
                  break;

                case 127:
                  _context.t20 = write;
                  _context.next = 130;
                  return raft.packet('error', 'Unknown message type: ' + packet.type);

                case 130:
                  _context.t21 = _context.sent;
                  (0, _context.t20)(_context.t21);

                case 132:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }()); //
      // We do not need to execute the rest of the functionality below as we're
      // currently running as "child" raft of the cluster not as the "root" raft.
      //

      if (Raft.CHILD === raft.state) return raft.emit('initialize'); //
      // Setup the log & appends. Assume that if we're given a function log that it
      // needs to be initialized as it requires access to our raft instance so it
      // can read our information like our leader, state, term etc.
      //

      if ('function' === raft.type(raft.Log)) {
        raft.log = new raft.Log(raft, options);
      }
      /**
       * The raft is now listening to events so we can start our heartbeat timeout.
       * So that if we don't hear anything from a leader we can promote our selfs to
       * a candidate state.
       *
       * Start listening listening for heartbeats when implementors are also ready
       * with setting up their code.
       *
       * @api private
       */


      function initialize(err) {
        if (err) return raft.emit('error', err);
        raft.emit('initialize');
        raft.heartbeat(raft.timeout());
      }

      if ('function' === raft.type(raft.initialize)) {
        if (raft.initialize.length === 2) return raft.initialize(options, initialize);
        raft.initialize(options);
      }

      initialize();
    }
    /**
     * Proper type checking.
     *
     * @param {Mixed} of Thing we want to know the type of.
     * @returns {String} The type.
     * @private
     */

  }, {
    key: "type",
    value: function type(of) {
      return Object.prototype.toString.call(of).slice(8, -1).toLowerCase();
    }
    /**
     * Check if we've reached our quorum (a.k.a. minimum amount of votes requires
     * for a voting round to be considered valid) for the given amount of votes.
     *
     * @param {Number} responses Amount of responses received.
     * @returns {Boolean}
     * @public
     */

  }, {
    key: "quorum",
    value: function quorum(responses) {
      if (!this.nodes.length || !responses) return false;
      return responses >= this.majority();
    }
    /**
     * The majority required to reach our the quorum.
     *
     * @returns {Number}
     * @public
     */

  }, {
    key: "majority",
    value: function majority() {
      return Math.ceil(this.nodes.length / 2) + 1;
    }
    /**
     * Attempt to run a function indefinitely until the callback is called.
     *
     * @param {Function} attempt Function that needs to be attempted.
     * @param {Function} fn Completion callback.
     * @param {Number} timeout Which timeout should we use.
     * @returns {Raft}
     * @public
     */

  }, {
    key: "indefinitely",
    value: function indefinitely(attempt, fn, timeout) {
      var uuid = UUID(),
          raft = this;

      (function again() {
        //
        // We need to force async execution here because we do not want to saturate
        // the event loop with sync executions. We know that it's important these
        // functions are retried indefinitely but if it's called synchronously we will
        // not have time to receive data or updates.
        //
        var next = one(function force(err, data) {
          if (!raft.timers) return; // We're been destroyed, ignore all.

          raft.timers.setImmediate(uuid + '@async', function async() {
            if (err) {
              raft.emit('error', err);
              return again();
            }

            fn(data);
          });
        }); //
        // Ensure that the assigned callback has the same context as our raft.
        //

        attempt.call(raft, next);
        raft.timers.setTimeout(uuid, function timeoutfn() {
          next(new Error('Timed out, attempting to retry again'));
        }, +timeout || raft.timeout());
      })();

      return this;
    }
    /**
     * Start or update the heartbeat of the Raft. If we detect that we've received
     * a heartbeat timeout we will promote our selfs to a candidate to take over the
     * leadership.
     *
     * @param {String|Number} duration Time it would take for the heartbeat to timeout.
     * @returns {Raft}
     * @private
     */

  }, {
    key: "heartbeat",
    value: function heartbeat(duration) {
      var raft = this;
      duration = duration || raft.beat;

      if (raft.timers.active('heartbeat')) {
        raft.timers.adjust('heartbeat', duration);
        return raft;
      }

      raft.timers.setTimeout('heartbeat',
      /*#__PURE__*/
      _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var packet;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(Raft.LEADER !== raft.state)) {
                  _context2.next = 3;
                  break;
                }

                raft.emit('heartbeat timeout');
                return _context2.abrupt("return", raft.promote());

              case 3:
                _context2.next = 5;
                return raft.packet('append');

              case 5:
                packet = _context2.sent;
                raft.emit('heartbeat', packet);
                raft.message(Raft.FOLLOWER, packet).heartbeat(raft.beat);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      })), duration);
      return raft;
    }
    /**
     * Send a message to connected nodes within our cluster. The following messaging
     * patterns (who) are available:
     *
     * - Raft.LEADER   : Send a message to cluster's current leader.
     * - Raft.FOLLOWER : Send a message to all non leaders.
     * - Raft.CHILD    : Send a message to everybody.
     * - <address>     : Send a message to a raft based on the address.
     *
     * @param {Mixed} who Recipient of the message.
     * @param {Mixed} what The data we need to send.
     * @param {Function} when Completion callback
     * @returns {Raft}
     * @public
     */

  }, {
    key: "message",
    value: function message(who, what, when) {
      when = when || nope; //
      // If the "who" is undefined, the developer made an error somewhere. Tell them!
      //

      if (typeof who === 'undefined') {
        throw new Error('Cannot send message to `undefined`. Check your spelling!');
      }

      var output = {
        errors: {},
        results: {}
      },
          length = this.nodes.length,
          errors = false,
          latency = [],
          raft = this,
          nodes = [],
          i = 0;

      switch (who) {
        case Raft.LEADER:
          for (; i < length; i++) {
            if (raft.leader === raft.nodes[i].address) {
              nodes.push(raft.nodes[i]);
            }
          }

          break;

        case Raft.FOLLOWER:
          for (; i < length; i++) {
            if (raft.leader !== raft.nodes[i].address) {
              nodes.push(raft.nodes[i]);
            }
          }

          break;

        case Raft.CHILD:
          Array.prototype.push.apply(nodes, raft.nodes);
          break;

        default:
          for (; i < length; i++) {
            if (who === raft.nodes[i].address) {
              nodes.push(raft.nodes[i]);
            }
          }

      }
      /**
       * A small wrapper to force indefinitely sending of a certain packet.
       *
       * @param {Raft} client Raft we need to write a message to.
       * @param {Object} data Message that needs to be send.
       * @api private
       */


      function wrapper(client, data) {
        var start = +new Date();
        client.write(data, function written(err, data) {
          latency.push(+new Date() - start); //
          // Add the error or output to our `output` object to be
          // passed to the callback when all the writing is done.
          //

          if (err) {
            errors = true;
            output.errors[client.address] = err;
          } else {
            output.results[client.address] = data;
          } //
          // OK, so this is the strange part here. We've broadcasted messages and
          // got replies back. This reply contained data so we need to process it.
          // What if the data is incorrect? Then we have no way at the moment to
          // send back reply to a reply to the server.
          //


          if (err) raft.emit('error', err);else if (data) raft.emit('data', data); //
          // Messaging has been completed.
          //

          if (latency.length === length) {
            raft.timing(latency);
            when(errors ? output.errors : undefined, output.results);
            latency.length = nodes.length = 0;
            output = null;
          }
        });
      }

      length = nodes.length;
      i = 0;

      for (; i < length; i++) {
        wrapper(nodes[i], what);
      }

      return raft;
    }
  }, {
    key: "timeout",

    /**
     * Generate the various of timeouts.
     *
     * @returns {Number}
     * @private
     */
    value: function timeout() {
      var times = this.election;
      return Math.floor(Math.random() * (times.max - times.min + 1) + times.min);
    }
    /**
     * Calculate if our average latency causes us to come dangerously close to the
     * minimum election timeout.
     *
     * @param {Array} latency Latency of the last broadcast.
     * @param {Boolean} Success-fully calculated the threshold.
     * @private
     */

  }, {
    key: "timing",
    value: function timing(latency) {
      var raft = this,
          sum = 0,
          i = 0;
      if (Raft.STOPPED === raft.state) return false;

      for (; i < latency.length; i++) {
        sum += latency[i];
      }

      raft.latency = Math.floor(sum / latency.length);

      if (raft.latency > raft.election.min * raft.threshold) {
        raft.emit('threshold');
      }

      return true;
    }
    /**
     * Raft ยง5.2:
     *
     * We've detected a timeout from the leaders heartbeats and need to start a new
     * election for leadership. We increment our current term, set the CANDIDATE
     * state, vote our selfs and ask all others rafts to vote for us.
     *
     * @returns {Raft}
     * @private
     */

  }, {
    key: "promote",
    value: function () {
      var _promote = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var raft, packet;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                raft = this;
                raft.change({
                  state: Raft.CANDIDATE,
                  // We're now a candidate,
                  term: raft.term + 1,
                  // but only for this term.
                  leader: '' // We no longer have a leader.

                }); //
                // Candidates are always biased and vote for them selfs first before sending
                // out a voting request to all other rafts in the cluster.
                //

                raft.votes.for = raft.address;
                raft.votes.granted = 1; //
                // Broadcast the voting request to all connected rafts in your private
                // cluster.
                //

                _context3.next = 6;
                return raft.packet('vote');

              case 6:
                packet = _context3.sent;
                raft.message(Raft.FOLLOWER, packet); //
                // Set the election timeout. This gives the rafts some time to reach
                // consensuses about who they want to vote for. If no consensus has been
                // reached within the set timeout we will attempt it again.
                //

                raft.timers.clear('heartbeat, election').setTimeout('election', raft.promote, raft.timeout());
                return _context3.abrupt("return", raft);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function promote() {
        return _promote.apply(this, arguments);
      };
    }()
    /**
     * Wrap the outgoing messages in an object with additional required data.
     *
     * @async
     * @param {String} type Message type we're trying to send.
     * @param {Mixed} data Data to be transfered.
     * @returns {Promise<Object>} Packet.
     * @private
     */

  }, {
    key: "packet",
    value: function () {
      var _packet = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(type, data) {
        var raft,
            wrapped,
            _args4 = arguments;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                raft = this, wrapped = {
                  state: raft.state,
                  // Are we're a leader, candidate or follower.
                  term: raft.term,
                  // Our current term so we can find mis matches.
                  address: raft.address,
                  // Address of the sender.
                  type: type,
                  // Message type.
                  leader: raft.leader // Who is our leader.

                }; //
                // If we have logging and state replication enabled we also need to send this
                // additional data so we can use it determine the state of this raft.
                //

                if (!raft.log) {
                  _context4.next = 5;
                  break;
                }

                _context4.next = 4;
                return raft.log.getLastInfo();

              case 4:
                wrapped.last = _context4.sent;

              case 5:
                if (_args4.length === 2) wrapped.data = data;
                return _context4.abrupt("return", wrapped);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function packet(_x3, _x4) {
        return _packet.apply(this, arguments);
      };
    }()
    /**
     * appendPacket - Send append message with entry and using the previous entry as the last.index and last.term
     *
     * @param {Entry} entry Entry to send as data
     *
     * @return {Promise<object>} Description
     * @private
     */

  }, {
    key: "appendPacket",
    value: function () {
      var _appendPacket = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(entry) {
        var raft, last;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                raft = this;
                _context5.next = 3;
                return raft.log.getEntryInfoBefore(entry);

              case 3:
                last = _context5.sent;
                return _context5.abrupt("return", {
                  state: raft.state,
                  // Are we're a leader, candidate or follower.
                  term: raft.term,
                  // Our current term so we can find mis matches.
                  address: raft.address,
                  // Address of the sender.
                  type: 'append',
                  // Append message type .
                  leader: raft.leader,
                  // Who is our leader.
                  data: [entry],
                  // The command to send to the other nodes
                  last: last
                });

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function appendPacket(_x5) {
        return _appendPacket.apply(this, arguments);
      };
    }()
    /**
     * Create a clone of the current instance with the same configuration. Ideally
     * for creating connected nodes in a cluster.. And let that be something we're
     * planning on doing.
     *
     * @param {Object} options Configuration that should override the default config.
     * @returns {Raft} The newly created instance.
     * @public
     */

  }, {
    key: "clone",
    value: function clone(options) {
      options = options || {};
      var raft = this,
          node = {
        'Log': raft.Log,
        'election max': raft.election.max,
        'election min': raft.election.min,
        'heartbeat': raft.beat,
        'threshold': raft.threshold
      },
          key;

      for (key in node) {
        if (key in options || !node.hasOwnProperty(key)) continue;
        options[key] = node[key];
      }

      return new raft.constructor(options);
    }
    /**
     * A new raft is about to join the cluster. So we need to upgrade the
     * configuration of every single raft.
     *
     * @param {String} address The address of the raft that is connected.
     * @param {Function} write A method that we use to write data.
     * @returns {Raft} The raft we created and that joined our cluster.
     * @public
     */

  }, {
    key: "join",
    value: function join(address, write) {
      var raft = this; // can be function or asyncfunction

      if (/function/.test(raft.type(address))) {
        write = address;
        address = null;
      } //
      // You shouldn't be able to join the cluster as your self. So we're going to
      // add a really simple address check here. Return nothing so people can actually
      // check if a raft has been added.
      //


      if (raft.address === address) return;
      var node = raft.clone({
        write: write,
        // Optional function that receives our writes.
        address: address,
        // A custom address for the raft we added.
        state: Raft.CHILD // We are a raft in the cluster.

      });
      node.once('end', function end() {
        raft.leave(node);
      }, raft);
      raft.nodes.push(node);
      raft.emit('join', node);
      return node;
    }
    /**
     * Remove a raft from the cluster.
     *
     * @param {String} address The address of the raft that should be removed.
     * @returns {Raft} The raft that we removed.
     * @public
     */

  }, {
    key: "leave",
    value: function leave(address) {
      var raft = this,
          index = -1,
          node;

      for (var i = 0; i < raft.nodes.length; i++) {
        if (raft.nodes[i] === address || raft.nodes[i].address === address) {
          node = raft.nodes[i];
          index = i;
          break;
        }
      }

      if (~index && node) {
        raft.nodes.splice(index, 1);
        if (node.end) node.end();
        raft.emit('leave', node);
      }

      return node;
    }
    /**
     * This Raft needs to be shut down.
     *
     * @returns {Boolean} Successful destruction.
     * @public
     */

  }, {
    key: "end",
    value: function end() {
      var raft = this;
      if (Raft.STOPPED === raft.state) return false;
      raft.change({
        state: Raft.STOPPED
      });
      if (raft.nodes.length) for (var i = 0; i < raft.nodes.length; i++) {
        raft.leave(raft.nodes[i]);
      }
      raft.emit('end');
      raft.timers.end();
      raft.removeAllListeners();
      if (raft.log) raft.log.end();
      raft.timers = raft.Log = raft.beat = raft.election = null;
      return true;
    }
    /**
     * Raft ยง5.3:
     * command - Saves command to log and replicates to followers
     *
     * @param {type} command Json command to be stored in the log
     *
     * @return {Promise<void>} Description
     */

  }, {
    key: "command",
    value: function () {
      var _command2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(_command) {
        var raft, entry, appendPacket;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                raft = this;

                if (!(raft.state !== Raft.LEADER)) {
                  _context6.next = 3;
                  break;
                }

                return _context6.abrupt("return", fn({
                  message: 'NOTLEADER',
                  leaderAddress: raft.leader
                }));

              case 3:
                _context6.next = 5;
                return raft.log.saveCommand(_command, raft.term);

              case 5:
                entry = _context6.sent;
                _context6.next = 8;
                return raft.appendPacket(entry);

              case 8:
                appendPacket = _context6.sent;
                raft.message(Raft.FOLLOWER, appendPacket);

              case 10:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function command(_x6) {
        return _command2.apply(this, arguments);
      };
    }()
    /**
     * commitEntries - Commites entries in log and emits commited entries
     *
     * @param {Entry[]} entries Entries to commit
     * @return {Promise<void>}
     */

  }, {
    key: "commitEntries",
    value: function () {
      var _commitEntries = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(entries) {
        var _this2 = this;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                entries.forEach(
                /*#__PURE__*/
                function () {
                  var _ref5 = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee7(entry) {
                    return regeneratorRuntime.wrap(function _callee7$(_context7) {
                      while (1) {
                        switch (_context7.prev = _context7.next) {
                          case 0:
                            _context7.next = 2;
                            return _this2.log.commit(entry.index);

                          case 2:
                            _this2.emit('commit', entry.command);

                          case 3:
                          case "end":
                            return _context7.stop();
                        }
                      }
                    }, _callee7, this);
                  }));

                  return function (_x8) {
                    return _ref5.apply(this, arguments);
                  };
                }());

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function commitEntries(_x7) {
        return _commitEntries.apply(this, arguments);
      };
    }()
  }]);

  return Raft;
}(EventEmitter);
/**
 * Raft ยง5.1:
 *
 * A Raft can be in only one of the various states. The stopped state is not
 * something that is part of the Raft protocol but something we might want to
 * use internally while we're starting or shutting down our node. The following
 * states are generated:
 *
 * - STOPPED:   Assume we're dead.
 * - LEADER:    We're selected as leader process.
 * - CANDIDATE: We want to be promoted to leader.
 * - FOLLOWER:  We're just following a leader.
 * - CHILD:     A node that has been added using JOIN.
 *
 * @type {Number}
 * @private
 */


Raft.states = 'STOPPED,LEADER,CANDIDATE,FOLLOWER,CHILD'.split(',');

for (var s = 0; s < Raft.states.length; s++) {
  Raft[Raft.states[s]] = s;
}

module.exports = Raft;