function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var encode = require('encoding-down');

var levelup = require('levelup');
/**
 * @typedef Entry
 * @property {number} index the key for the entry
 * @property {number} term the term that the entry was saved in
 * @property {boolean} Committed if the entry has been committed
 * @property {array}  responses number of followers that have saved the log entry
 * @property {object}  command The command to be used in the raft state machine
 */


var Log =
/*#__PURE__*/
function () {
  /**
   * @class
   * @param {object} node    The raft node using this log
   * @param {object} Options         Options object
   * @param {object}   Options.[adapter= require('leveldown')] Leveldown adapter, defaults to leveldown
   * @param {string}   Options.[path='./']    Path to save the log db to
   * @return {Log}
   */
  function Log(node, _ref) {
    var _ref$adapter = _ref.adapter,
        adapter = _ref$adapter === void 0 ? require('leveldown') : _ref$adapter,
        _ref$path = _ref.path,
        path = _ref$path === void 0 ? '' : _ref$path;

    _classCallCheck(this, Log);

    this.node = node;
    this.committedIndex = 0;
    this.db = levelup(encode(adapter(path), {
      valueEncoding: 'json',
      keyEncoding: 'binary'
    }));
  }
  /**
   * saveCommand - Saves a command to the log
   * Initially the command is uncommitted. Once a majority
   * of follower nodes have saved the log entry it will be
   * committed.
   *
   * A follow node will also use this method to save a received command to
   * its log
   *
   * @async
   * @param {object} command A json object to save to the log
   * @param {number} term    Term to save with the log entry
   * @param {number} [index] Index to save the entry with. This is used by the followers
   * @return {Promise<entry>} Description
   */


  _createClass(Log, [{
    key: "saveCommand",
    value: function () {
      var _saveCommand = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(command, term, index) {
        var _ref2, lastIndex, entry;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (index) {
                  _context.next = 6;
                  break;
                }

                _context.next = 3;
                return this.getLastInfo();

              case 3:
                _ref2 = _context.sent;
                lastIndex = _ref2.index;
                index = lastIndex + 1;

              case 6:
                entry = {
                  term: term,
                  index: index,
                  committed: false,
                  responses: [{
                    address: this.node.address,
                    // start with vote from leader
                    ack: true
                  }],
                  command: command
                };
                _context.next = 9;
                return this.put(entry);

              case 9:
                return _context.abrupt("return", entry);

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function saveCommand(_x, _x2, _x3) {
        return _saveCommand.apply(this, arguments);
      };
    }()
    /**
     * put - Save entry to database using the index as the key
     *
     * @async
     * @param {Entry} entry entry to save
     * @return {Promise<void>} Resolves once entry is saved
     * @public
     */

  }, {
    key: "put",
    value: function put(entry) {
      return this.db.put(entry.index, entry);
    }
    /**
     * getEntriesAfter - Get all the entries after a specific index
     *
     * @param {number} index Index that entries must be greater than
     * @return {Promise<Entry[]>} returns all entries
     * @public
     */

  }, {
    key: "getEntriesAfter",
    value: function getEntriesAfter(index) {
      var _this = this;

      var entries = [];
      return new Promise(function (resolve, reject) {
        _this.db.createReadStream({
          gt: index
        }).on('data', function (data) {
          entries.push(data.value);
        }).on('error', function (err) {
          reject(err);
        }).on('end', function () {
          resolve(entries);
        });
      });
    }
    /**
     * removeEntriesAfter - Removes all entries after a given index
     *
     * @async
     * @param {Number} index Index to use to find all entries after
     * @return {Promise<void>} Returns once all antries are removed
     * @public
     */

  }, {
    key: "removeEntriesAfter",
    value: function () {
      var _removeEntriesAfter = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(index) {
        var _this2 = this;

        var entries;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getEntriesAfter(index);

              case 2:
                entries = _context2.sent;
                return _context2.abrupt("return", Promise.all(entries.map(function (entry) {
                  return _this2.db.del(entry.index);
                })));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function removeEntriesAfter(_x4) {
        return _removeEntriesAfter.apply(this, arguments);
      };
    }()
    /**
     * has - Checks if entry exists at index
     *
     * @async
     * @param {number} index Index position to check if entry exists
     * @return {boolean} Boolean on whether entry exists at index
     * @public
     */

  }, {
    key: "has",
    value: function () {
      var _has = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(index) {
        var entry;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return this.db.get(index);

              case 3:
                entry = _context3.sent;
                return _context3.abrupt("return", true);

              case 7:
                _context3.prev = 7;
                _context3.t0 = _context3["catch"](0);
                return _context3.abrupt("return", false);

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 7]]);
      }));

      return function has(_x5) {
        return _has.apply(this, arguments);
      };
    }()
    /**
     * get - Gets an entry at the specified index position
     *
     * @param {type} index Index position of entry
     * @return {Promise<Entry>} Promise of found entry returns NotFoundError if does not exist
     * @public
     */

  }, {
    key: "get",
    value: function get(index) {
      return this.db.get(index);
    }
    /**
     * getLastInfo - Returns index, term of the last entry in the long along with
     * the committedIndex
     *
     * @async
     * @return {Promise<Object>} Last entries index, term and committedIndex
     */

  }, {
    key: "getLastInfo",
    value: function () {
      var _getLastInfo = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var _ref3, index, term;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getLastEntry();

              case 2:
                _ref3 = _context4.sent;
                index = _ref3.index;
                term = _ref3.term;
                return _context4.abrupt("return", {
                  index: index,
                  term: term,
                  committedIndex: this.committedIndex
                });

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function getLastInfo() {
        return _getLastInfo.apply(this, arguments);
      };
    }()
    /**
     * getLastEntry - Returns last entry in the log
     *
     * @return {Promise<Entry>} returns {index: 0, term: node.term} if there are no entries in the log
     */

  }, {
    key: "getLastEntry",
    value: function getLastEntry() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var hasResolved = false;
        var entry = {
          index: 0,
          term: _this3.node.term
        };

        _this3.db.createReadStream({
          reverse: true,
          limit: 1
        }).on('data', function (data) {
          hasResolved = true;
          entry = data.value;
        }).on('error', function (err) {
          hasResolved = true;
          reject(err);
        }).on('end', function () {
          resolve(entry);
        });
      });
    }
    /**
     * getEntryInfoBefore - Gets the index and term of the previous entry along with the log's committedIndex
     * If there is no item before it returns {index: 0}
     *
     *
     * @async
     * @param {Entry} entry
     * @return {Promise<object>} {index, term, committedIndex}
     */

  }, {
    key: "getEntryInfoBefore",
    value: function () {
      var _getEntryInfoBefore = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(entry) {
        var _ref4, index, term;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getEntryBefore(entry);

              case 2:
                _ref4 = _context5.sent;
                index = _ref4.index;
                term = _ref4.term;
                return _context5.abrupt("return", {
                  index: index,
                  term: term,
                  committedIndex: this.committedIndex
                });

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getEntryInfoBefore(_x6) {
        return _getEntryInfoBefore.apply(this, arguments);
      };
    }()
    /**
     * getEntryBefore - Get entry before the specified entry
     * If there is no item before it returns {index: 0}
     *
     * @async
     * @param {Entry} entry
     *
     * @return {Promise<Entry>}
     */

  }, {
    key: "getEntryBefore",
    value: function getEntryBefore(entry) {
      var _this4 = this;

      var defaultInfo = {
        index: 0,
        term: this.node.term
      }; // We know it is the first entry, so save the query time

      if (entry.index === 1) {
        return Promise.resolve(defaultInfo);
      }

      return new Promise(function (resolve, reject) {
        var hasResolved = false;

        _this4.db.createReadStream({
          reverse: true,
          limit: 1,
          lt: entry.index
        }).on('data', function (data) {
          hasResolved = true;
          resolve(data.value);
        }).on('error', function (err) {
          hasResolved = true;
          reject(err);
        }).on('end', function () {
          if (!hasResolved) {
            // Returns empty index if there is no items
            // before entry or log is empty
            resolve(defaultInfo);
          }
        });
      });
    }
    /**
     * commandAck - acknowledges a follow with address has stored entry at index
     * This is used to determine if a quorom has been met for a log entry and
     * if enough followers have stored it so that it can be committed
     *
     * @async
     * @param {number} index   Index of entry that follow has stored
     * @param {string} address Address of follower that has stored log
     * @return {Promise<Entry>}
     */

  }, {
    key: "commandAck",
    value: function () {
      var _commandAck = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(index, address) {
        var entry, entryIndex;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.prev = 0;
                _context6.next = 3;
                return this.get(index);

              case 3:
                entry = _context6.sent;
                _context6.next = 9;
                break;

              case 6:
                _context6.prev = 6;
                _context6.t0 = _context6["catch"](0);
                return _context6.abrupt("return", {
                  responses: []
                });

              case 9:
                _context6.next = 11;
                return entry.responses.findIndex(function (resp) {
                  return resp.address === address;
                });

              case 11:
                entryIndex = _context6.sent;

                // node hasn't voted yet. Add response
                if (entryIndex === -1) {
                  entry.responses.push({
                    address: address,
                    ack: true
                  });
                }

                _context6.next = 15;
                return this.put(entry);

              case 15:
                return _context6.abrupt("return", entry);

              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[0, 6]]);
      }));

      return function commandAck(_x7, _x8) {
        return _commandAck.apply(this, arguments);
      };
    }()
    /**
     * commit - Set the entry to committed
     *
     * @async
     * @param {number} Index index
     *
     * @return {Promise<entry>}
     */

  }, {
    key: "commit",
    value: function () {
      var _commit = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(index) {
        var entry;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.db.get(index);

              case 2:
                entry = _context7.sent;
                entry.committed = true;
                this.committedIndex = entry.index;
                return _context7.abrupt("return", this.put(entry));

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function commit(_x9) {
        return _commit.apply(this, arguments);
      };
    }()
    /**
     * getUncommittedEntriesUpToIndex - Returns all entries before index that have not been committed yet
     *
     * @param {number} index Index value to find all entries up to
     * @return {Promise<Entry[]}
     * @private
     */

  }, {
    key: "getUncommittedEntriesUpToIndex",
    value: function getUncommittedEntriesUpToIndex(index) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var hasResolved = false;
        var entries = [];

        _this5.db.createReadStream({
          gt: _this5.committedIndex,
          lte: index
        }).on('data', function (data) {
          if (!data.value.committed) {
            entries.push(data.value);
          }
        }).on('error', function (err) {
          reject(err);
        }).on('end', function () {
          resolve(entries);
        });
      });
    }
    /**
     * end - Log end
     * Called when the node is shutting down
     *
     * @return {boolean} Successful close.
     * @private
     */

  }, {
    key: "end",
    value: function end() {
      return this.db.close();
    }
  }]);

  return Log;
}();

;
module.exports = Log;